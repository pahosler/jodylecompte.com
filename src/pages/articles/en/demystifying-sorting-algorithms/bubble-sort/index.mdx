import Image from 'next/image';

import { ArticleLayout } from '@/components/ArticleLayout';
import { DSAPreface } from '@/components/articles/DSAPreface';

export const meta = {
  author: 'Jody LeCompte',
  date: '2022-12-26',
  title: 'Demystifying Sorting Algorithms: Bubble Sort',
  seoImage: '/articles/dsaBubbleSort.webp',
  description: `In part one of Demystifying Sorting Algorithms`,
};

export default (props) => <ArticleLayout meta={meta} {...props} />;

<Image
  src="/articles/dsaBubbleSort.webp"
  alt=""
  width="640"
  height="420"
  aria-hidden="true"
/>

{meta.description}

<DSAPreface />

## Introduction to the Bubble Sort

Bubble sort in most cases might be the least performant bubble sort, so it is not one that you will
find in many code-bases. However, it is still a good starting point in this series to get our feet wet
because the implementation is extremely trivial to implement.

Bubble sort is a swap based algorithm. It steps through the array using a nested loop and compares each
item to the adjacent items in pairs. If it encounters an instance where the second element in each pair,
or the number to the right, is smaller than the first on the left, those two elements are swapped.

The first implementation we will look at has a time complexity of O(N^2). What does that mean? It means
that the time it takes to sort will grow exponentially to `N` where `N`` is the size of the list.
If we attempt to sort a list with 5 numbers, it will take 15 iterations. From there a collection size of 6
numbers would iterate 20 times, and 27 iterations for 7 numbers. This scaling is what makes sorting algorithms
like bubble suit unsuitable for large datasets.

## Stepping through

Before we get our hands dirty with the code, let's step through the process step by step first, don't worry
we are just going to do the first inner loop.

Given the following sample set:

```javascript
const unsorted = [219, 5, 1, 75, 15];
```

Step 1: Compare 219 and 5, 219 is greater, so swap

```javascript
const unsorted = [5, 219, 1, 75, 15];
```

Step 2: Compare 219 and 1, 219 is great so swap

```javascript
const unsorted = [5, 1, 219, 75, 15];
```

Step 3. Compare 219 and 75, 219 is greater, so swap

```javascript
const unsorted = [5, 1, 75, 219, 15];
```

Step 4. Compare 219 and 15, 219 is greater, so swap.

```javascript
const unsorted = [5, 1, 75, 15, 219];
```

The list is not sorted yet, so we will have to make a few more passes, but this illustrates the crux of the process.
An important take-away is that `219` was shifted all the way to the end of the list. This isn't simply because
219 came first, but the bubble sort by design will always find and highest value in the list and place it as far
right as appropriated each time the outer loop runs. This is an important detail to keep in mind when we structure our
loops.

## Initial Implementation

Let's start with an initial implementation, then after stepping through the code, we can take a look at potential improvements.

```javascript
function bubbleSort(collection) {
  for (let i = 0; i < collection.length - 1; i++) {
    for (let j = 0; j < collection.length - i - 1; j++) {
      if (collection[j] > collection[j + 1]) {
        let tmp = collection[j + 1];
        collection[j + 1] = collection[j];
        collection[j] = tmp;
      }
    }
  }

  return collection;
}
```

The outer loop is really only used to calculate the offset and facilitate the number of iterations necessary
to fully sort, is isn't used for actual index lookups in the input. But take note of the inner loop. The terminating
condition gets one item shorter each time the outer loop runs to reflect the fact that the last `i + 1` items
in the list are known to be sorted already.

In the instances where we find a higher left hand value, we swap to the right. The above code for swapping is
what you will see in a lot of code that predates ES6, but we can clean this up a little bit using array
destructuring to swap the values without using a temp variable.

```javascript
function bubbleSort(collection) {
  for (let i = 0; i < collection.length - 1; i++) {
    for (let j = 0; j < collection.length - i - 1; j++) {
      if (collection[j] > collection[j + 1]) {
        [collection[j], collection[j + 1]] = [collection[j + 1], collection[j]];
      }
    }
  }

  return collection;
}
```

## A Light Seasoning of Optimization

As mentioned previously, the above implementation will always be the worst case of O(N^2), because there is no safe-guard
against unnecessary iteration. For example, the first sample was pretty mixed up, but what if our array was mostly already
sorted.

```javascript
const unsorted = [219, 5, 7, 9, 12];
```

Just like when stepping through the collection earlier, at the end of the first outer loop iteration, the above
list would be completely sorted with 219 appearing to the far right. But then it would continue to iterate needlessly
until `i` in our outer loop matches the length of the array.

We can solve this by adding a simple swap indicator, a boolean value that will start as false and be changed to true
if we swap at any point in the inner loop. Then before the outer loop concludes and restarts, we can make the assertion
that if no swaps happened in the last inner loop iterations, then we can return as the list as sorted.

```javascript
function bubbleSortOptimized(collection) {
  for (let i = 0; i < collection.length - 1; i++) {
    let swapped = false;

    for (let j = 0; j < collection.length - i - 1; j++) {
      if (collection[j] > collection[j + 1]) {
        swapped = true;
        [collection[j], collection[j + 1]] = [collection[j + 1], collection[j]];
      }
    }

    if (!swapped) return collection;
  }

  return collection;
}
```

It's not an enormous savings, but this does bring down the example collection from 14 iterations to 9 iterations,
contrasted against only decreasing from 14 to 12 for the original data set. The take-away here is that algorithms
don't always have a consistent runtime complexity. With this optimization. With this optimization, we can now achieve
a rare, but much better runtime for nearly-sorted list, but the average list will still be (N^2) like the un-optimized
example.

## Conclusion

The [source code](https://github.com/jodylecompte/lesson-sorting-algorithms) for this and all articles in this series
can be found on Github.

[Keep reading: Insertion Sort](/articles/en/demystifying-sorting-algorithms/selection-sort)
